from PyQt5.QtWidgets import QFileDialog

import NotesExtract
import tts
import requests

    _file_dir = ''  # pptx文件路径
    _save_dir = ''  # 视频保存路径
    _page = 1  # 当前幻灯片所在页数
    _notes = []  # 备注列表
    _pinyin = []  # 存储备注的拼音
    _gender_opt = '100453'  # 默认主播ID
    _translate = QtCore.QCoreApplication.translate

        MainWindow.setFixedSize(550, 160)

        self.ChooseFileButton.clicked.connect(self.openfile)
        self.ChooseSavedDirButton.clicked.connect(self.savefile)
        self.ConvertButton.clicked.connect(lambda: self.convert(MainWindow))
        self.PreSlideButton.clicked.connect(lambda: self._display(True))
        self.NextSlideButton.clicked.connect(lambda: self._display())
        self.CompleteButton_2.clicked.connect(self.checked_download)

    def openfile(self):
        openfile_name = QFileDialog.getOpenFileName(None, '选择文件', '', 'Pptx files(*.pptx)')
        self._file_dir = openfile_name[0]
        self.FileDirBlank.setText(self._file_dir)
        notes = NotesExtract.ObtainPptNote(self._file_dir)

    def savefile(self):
        self._save_dir = QtWidgets.QFileDialog.getExistingDirectory(None, "getExistingDirectory", "./")
        self.SavedDirBlank.setText(self._save_dir)

    # 音频转换函数
    def convert(self, MainWindow):
        if self._file_dir == '':
            # self.StatusLabel.setText("文件目录为空!请检查后重试!")
            self.StatusLabel.setText(self._translate("MainWindow",
                                                     "<html><head/><body><p><span style=\" "
                                                     "font-size:14pt; color:#ff0000;\""
                                                     ">文件目录为空!请检查后重试!"
                                                     "</span></p></body></html>"))
            return
        if self._save_dir == '':
            # self.StatusLabel.setText("保存路径为空!请检查后重试!")
            self.StatusLabel.setText(self._translate("MainWindow",
                                                     "<html><head/><body><p><span style=\" "
                                                     "font-size:14pt; color:#ff0000;\""
                                                     ">保存路径为空!请检查后重试!"
                                                     "</span></p></body></html>"))
            return
        # 获取主播ID及备注内容
        self._gender_opt = self.ChooseSpeakerId.currentText()
        self._notes = NotesExtract.ObtainPptNote(self._file_dir)
        #  判断用户是否启用"拼音检查"
        if self.PinyinCheck.isChecked():
            if len(self._notes) != 1:
                self.NextSlideButton.setEnabled(True)
            # 调整窗口尺寸并居中显示
            MainWindow.setFixedSize(550, 450)
            screen = QDesktopWidget().screenGeometry()
            size = MainWindow.geometry()
            MainWindow.move((screen.width() - size.width()) / 2,
                            (screen.height() - size.height()) / 2)
            self._preview()
        else:
            self._download()

    # 将编辑单页幻灯片备注中的文字及拼音
    def _display(self, re=False):
        # 先将翻页前的拼音字段保存
        if self._page == len(self._pinyin) + 1 and self._notes[self._page - 1] != '\n':
            self._pinyin.append(self.PinyinEdit.toPlainText())
        elif self._page == len(self._pinyin) + 1:
            self._pinyin.append('\n')
        elif self._notes[self._page - 1] != '\n':
            self._pinyin[self._page - 1] = self.PinyinEdit.toPlainText()

        # 判断当前页数
        if re:
            self._page = self._page - 1
        else:
            self._page = self._page + 1
        self.StatusLabel.setText(self._translate("MainWindow",
                                                 "<html><head/><body><p><span style=\" "
                                                 "font-size:14pt; color:#0000cd;\""
                                                 ">请处理第" + str(self._page) + "页幻灯片!"
                                                                             "</span></p></body></html>"))

        # 获取并输出当前页的备注及拼音
        # 清空当前文本框中的内容
        self.TextBrowser.clear()
        self.PinyinEdit.clear()

        # 判断是否需要更新拼音数组
        if self._page == len(self._pinyin) + 1:
            slide = tts.tts(self._notes[self._page - 1], "100453", True, True)
            if slide is None:
                self.TextBrowser.append("此页无备注!")
                self.PinyinEdit.appendPlainText(" ")
            else:
                self.TextBrowser.append(slide[0])
                self.PinyinEdit.appendPlainText(slide[1])
        else:
            self.TextBrowser.append(self._notes[self._page - 1])
            self.PinyinEdit.appendPlainText(self._pinyin[self._page - 1])

        # 根据读取的页数位置设置[上一页]和[下一页]按钮
        if self._page == 1 and len(self._notes) != 1:
            self.PreSlideButton.setEnabled(False)
            self.NextSlideButton.setEnabled(True)
        elif self._page == len(self._notes) and len(self._notes) != 1:
            self.PreSlideButton.setEnabled(True)
            self.NextSlideButton.setEnabled(False)
        elif 1 < self._page < len(self._notes):
            self.PreSlideButton.setEnabled(True)
            self.NextSlideButton.setEnabled(True)

        # 全部页数的幻灯片都处理完后将[修改完成]按键设置为可以点击
        if self._page == len(self._notes):
            self.CompleteButton_2.setEnabled(True)

    # 拼音预览函数
    def _preview(self):
        self.StatusLabel.setText(self._translate("MainWindow",
                                                 "<html><head/><body><p><span style=\" "
                                                 "font-size:14pt; color:#0000cd;\""
                                                 ">请处理第1页幻灯片!"
                                                 "</span></p></body></html>"))
        # 进行第一页幻灯片处理
        if self._notes[0] != '\n':
            slide = tts.tts(self._notes[0], "100453", True, True)
            self.TextBrowser.setText(slide[0])
            self.PinyinEdit.setPlainText(slide[1])
        else:
            self.TextBrowser.setText("此页无备注!")

    # 检查拼音后的下载方式
    def checked_download(self):
        # 如果最后一页的拼音数据没有保存,保存之
        if self._page == len(self._pinyin) + 1 and self._notes[self._page - 1] != '\n':
            self._pinyin.append(self.PinyinEdit.toPlainText())
        elif self._page == len(self._pinyin) + 1:
            self._pinyin.append('\n')
        # 拼音模式的语音合成
        self._download(False)

    # 通过接口下载音频
    def _download(self, is_text=True):
        for i in range(0, len(self._notes)):
            # 跳过空白备注
            if self._notes[i] == '\n':
                continue
            self.StatusLabel.setText(self._translate("MainWindow",
                                                     "<html><head/><body><p><span style=\" "
                                                     "font-size:14pt; color:#0000cd;\""
                                                     ">正在处理第" + str(i + 1) + "页幻灯片..."
                                                                             "</span></p></body></html>"))

            # 判断合成模式
            if is_text:
                chara = self._notes[i]
            else:
                chara = self._pinyin[i]
            url = tts.tts(chara, self._gender_opt, is_text)

            # 简易错误处理
            # TODO: 优化错误处理代码--转换为异常处理
            if url is None:
                self.StatusLabel.setText(self._translate("MainWindow",
                                                         "<html><head/><body><p><span style=\" "
                                                         "font-size:14pt; color:#ff0000;\""
                                                         ">转换出错!请重试!</span></p></body></html>"))
                return

            # 从网页下载音频
            f = requests.get(url)
            with open(str(i + 1) + ".wav", "wb") as code:
                code.write(f.content)
        self.StatusLabel.setText(self._translate("MainWindow",
                                                 "<html><head/><body><p><span style=\""
                                                 " font-size:14pt; color:#21ff06;\""
                                                 ">音频转换完成!</span></p></body></html>"))
